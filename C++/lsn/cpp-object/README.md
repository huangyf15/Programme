# 学习笔记

## 核心问题

* **认清“变”与“不变”**：世界很复杂，变化是永远存在的。唯一一种有效应对复杂变化的方法，就是找到变化中的不变，从而使我们用最少的变化去应对无穷无尽的变化。
* **遵守“开闭”原则**：是面向对象设计中“可复用设计”的基石，可增强程序的可复用性以及可维护性。软件实体应当对于扩展是开放的，而对于修改是关闭的。具体地讲，
	* “开”是指对于组件功能的扩展是开放的，是允许其进行功能扩展的；
	* “闭”是指对于原有代码的修改是封闭的，即修改原有的代码对外部的使用是透明的。

## 第六讲：算法横向拆分，分离步骤

## 第七讲：算法纵向拆分，分离表示

## 第八讲：基于接口组合，应对复杂变化（继承&组合，扩展-“开”）

* 常用模式
	* 功能不变、接口变化
		* 适配器模式：引入抽象的接口类，通过提供具体的实现类组合达到组合已有资源的目的
			* 具体包括，对象适配（利用组合实现）、类适配（利用多重继承实现）
		* 模板实例化：如使用 STL
	* 接口不变、功能变化
		* 代理模式：不改变原有对象的接口，通过增加控制步骤实现对被代理对象的控制
			* 如引用计数控制、权限控制、远程代理、延迟初始化等
		* 策略模式：用组合代替继承，通过动态改变预先定义好的策略以实现功能的改变
		* 装饰模式：用组合代替继承，通过给主体对象添加外加的附加功能以实现功能的改变
		* 责任链模式：将一系列的处理者连成一个链，将请求沿着这个链传递并由链上的处理者予以处理
	* 其他模式：监视器，命令模式，状态模式
* 模式对比
	* 装饰与策略
		* 相同点
			* 通过对象的组合修改对象的功能
			* 以组合替代继承，更加灵活
		* 不同点
			* 策略：修改对象功能的内核，且组件必须了解有哪些需要选择的策略
			* 装饰：修改对象功能的外壳，且组件无须了解有哪些可以装饰的内容
	* 装饰与代理
		* 相同点：都用来改变对象的行为，可以把装饰看成是一连串的代理
		* 不同点（记被装饰对象为“A”，被代理对象为“B”）
			* 装饰：为对象 A 增加额外的行为，不影响对象 A 的原有功能；不创建对象 A，只是将新功能添加到已有对象上；经常多重嵌套修饰
			* 代理：常用来对对象 B 进行更精细的控制；对象 B 不存在时常创建被代理对象；少见多重嵌套
	* 责任链与装饰
		* 相同点：两者都有调用链
		* 不同点
			* 责任链：强调调用链的行为
			* 装饰：强调调用链带来的组织结果
	* 责任链与代理
		* 相同点：把责任链看成一连串代理也不无不可
		* 不同点：
			* 代理：强调改变对象的行为，控制被代理对象
			* 责任链：强调组织多个对象的行为

## 第九讲：增加抽象层级，隔离复杂变化（封装&隔离，修改-“闭”）

* 通过封装增加隔离、应对变化
	* 方法：使用虚函数，基于接口进行编程而不依赖具体类
	* 意义：使同一段代码（算法）能处理不同性质的对象，增加了程序应对未来变化的灵活性
* 增加抽象层、应对变化
	* 方法：使用纯虚函数，把具体对象的创建交给派生类实现
	* 意义：既使基类能将无法决定的事情交由子类去确定，又使基类提供的接口不受信息的约束
* 相互关联多态对象的创建
	* 方法：将关联对象的生成接口集成（合并）到单个创建类 Creator 中
	* 意义：保证了在实现该类 ConcreteCreator 时各个对象之间的关联性符合要求，这种设计思路也被称为“抽象工厂(Abstract Factory)”模式
* 复杂对象多步骤任务的实现
	* 方法：分若干步骤创建复杂对象 Director ，各具体步骤由其他对象来实现
	* 意义：创建复杂对象的过程被拆分成一系列步骤，分别对应不同接口 Builder，这些接口派生内涵复杂、变体较多的子类 ConcreteBuilder，这种设计思路也被称为“建造者(Builder)”模式

## 拓展材料

* [OOP 设计模式](https://www.cnblogs.com/zhenw/p/6160931.html)
在面向对象编程的基础上发展出来的23种设计模式广泛应用于现今的软件工程中，极大方便了代码的书写与维护。

	* 创建型模式，共五种：工厂方法模式、**抽象工厂模式**、单例模式、**建造者模式**、原型模式。
	* 结构型模式，共七种：**适配器模式**、**装饰器模式**、**代理模式**、外观模式、桥接模式、组合模式、享元模式。
	* 行为型模式，共十一种：**策略模式**、模板方法模式、观察者模式、迭代子模式、**责任链模式**、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。


