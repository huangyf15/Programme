# 第二章 面向过程的编程风格

> Last updated: Aug 26, 2020
> Author: Yunfan Huang

### 本章内容

学习函数基本编写原则，包括：

* 函数调用、默认参数值、局部静态对象、`inline`函数
* 函数重载、函数模板、函数指针、`extern`和`const`对象

#### 程序案例

* `sort_bubble`：指针参数和引用参数的使用、参数默认值
* `cal_seq`：局部静态对象、`inline`函数、函数重载、函数模板、函数指针
* `def_const`：`extern`、`const`和`extern const`对象辨析

### 指针参数和引用参数的异同

* 效果相同：传递的是对象地址，而不是整个对象的副本。这一方面可以直接对所传入的对象进行修改，另一方面也可以降低复制大型对象的额外负担。
* 用法不同：二者的语法形式有所差别，而更重要的差异是
  * 指针可能（也可能不）指向某个实际对象，因此提取其指向的值时必须先确认指针非空
  * 引用必定代表某个对象，因此不需要做空指针类似的检查

### 作用域及范围

* 程序案例：`fibon`
* 为对象分配的内存的存活时间称为储存期（storage duration）或范围（extent）：static extent, local extent, dynamic extent
  * static extent 对象的内存在 `main()` 开始执行之前就已分配好，可一直存在至程序结束
  * dynamic extent 对象在运行时通过 `new` 表达式从 heap 分配而来，存活至 `delete` 释放为止
* 对象在程序内的存活区域称为该对象的作用域（scope）：file scope, local scope
  * file scope 内的对象从其声明点至文件末都是可见的，同时也具备 static extent
* “只定义一次”规则：一般要求对象或函数的定义只能有一份，并且必须放在程序代码文件中，`inline`函数和`const`对象除外

### inline/extern/const 对象的辨析

* 程序案例：`const`
* ``inline`函数：定义可以被多个程序代码文件取得，**属于“只定义一次”规则的例外**
  * 动机：为了能够扩展函数的内容，编译器在每个调用点上都能取得其定义，应在头文件中声明为`inline`函数并定义
* `extern`对象：只进行声明而不进行定义（推迟定义位置），**服从“只定义一次”规则**
  * 动机：为了处理在 file scope 内定义的并且可能被多个文件访问的对象，应在头文件中将其声明为`extern`对象
* `const `对象：必须初始化，默认不能被其他文件访问故可在多个程序代码中加以定义（除非加`extern`），**属于“只定义一次”规则的例外**
  * 动机：为了编译器在需要用到常量表达式的场合（可能跨文件）也能够使用该对象，应在头文件中将其声明为`const`对象
  * 特例：若起初直接声明为`extern const`对象，则外部可见但不可改动并且不可重复定义，可认为是理想常量
  * 注意：若将`const`对象进行`extern const`声明，经测试该声明并不能改变`const`对象的外部不可见性，即**声明无效**