# `THU01`

## 第1-4章：绪论，`C++`简单程序设计，函数、类与对象

### 面向对象的基本概念

* 对象
  * 一般意义上的对象：现实世界中实际存在的事物。
  * 面向对象方法中的对象：程序中用来描述客观事物的实体。
* 抽象与分类
  * 分类依据的原则——抽象；
  * 抽象出同一类对象的共同属性和行为形成类；
  * 类与对象是类型与实例的关系。
* 封装
  * 隐蔽对象的内部细节；
  * 对外形成一个边界；
  * 只保留有限的对外接口；
  * 使用方便、安全性好。
* 继承
  * 意义在于软件复用；
  * 改造、扩展已有类形成新的类。
* 多态
  * 同样的消息作用在不同对象上，可以引起不同的行为。

### 程序的开发过程

* 程序
  * 源程序：用源语言写的，有待翻译的程序；
  * 目标程序：源程序通过翻译程序加工以后生成的机器语言程序；
  * 可执行程序：连接目标程序以及库中的某些文件，生成的一个可执行文件。例如 Windows 系统平台上的 `.EXE` 文件。
* 三种不同类型的翻译程序
  * 汇编程序：将汇编语言源程序翻译成目标程序；
  * 编译程序：将高级语言源程序翻译成目标程序；
  * 解释程序：将高级语言源程序翻译成机器指令，边翻译边执行。
* C++程序的开发过程
  * 算法与数据结构设计；
  * 源程序编辑；
  * 编译，连接；
  * 测试，调试。

### 函数的调用与重载

* 函数的嵌套调用
* 函数的递归调用
* 函数的重载（多态性的体现）

### 函数的参数传递

* 值传递
  * 用于传递参数值，是一种单向传递
  * 从时间开销的角度，值传递要比引用传递更大
* 引用传递
  * 引用（`&`）是标识符的别名，可以作为形参，是一种双向传递
  * 使用引用传递可以实现多个返回值，而常引用可以保障实参数据的安全
  * 定义一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象
  ```c++
  #include <iostream>
  using namespace std;
  void swap_ref(int &a,int &b) {
    int t = a;
    a = b;
    b = t;
  }
  void swap_val(int a,int b) {
    int t = a;
    a = b;
    b = t;
  }
  int main() {
    int x = 5, y = 10;
    cout << "Origin: x =" << x << "; y =" << y << endl;
    swap_val(x,y);
    cout << "Value: x =" << x << "; y =" << y << endl;
    swap_ref(x,y);
    cout << "Reference: x =" << x << "; y =" << y << endl;
    return 0;
  }
  ```

### 特殊类型的函数

* 含有可变参数的函数
  * `C++` 标准中提供了两种主要的方法
    * 如果所有的实参类型相同，可以传递一个名为 `initializer_list` 的标准库类型
    * 如果实参的类型不同，我们可以编写可变参数的模板（第9章）
  * `initializer_list` 是一个类模板
    * 使用模板时，需要在模板名字后面跟一对尖括号，括号内给出类型参数，如
      * `initializer_list<string> ls;`
    * 对象中的元素永远是常量值，我们无法改变该对象中元素的值
    * 含有 `initializer_list` 形参的函数也可以同时拥有其他形参
* 内联函数
* 带默认参数值的函数

### 类的组合

* 前向引用声明某个类后，可在之后的其他类的成员函数中将该类作为参数类型使用

### 结构体、联合体与枚举类

* 结构体
  * 结构体是一种特殊形态的类
    * 与类的唯一区别：类的缺省访问权限是 `private`，结构体的缺省访问权限是`public`
    * 结构体存在的主要原因：与C语言保持兼容
  * 什么时候用结构体而不用类
    * 定义主要用来保存数据、而没有什么操作的类型
    * 人们习惯将结构体的数据成员设为公有，因此这时用结构体更方便
* 联合体
  * 声明形式与结构体相同
  * 成员共用同一组内存单元
  * 任何两个成员不会同时有效
* 枚举类
  * 声明形式
    * `enum class 枚举类型名: 底层类型 {枚举值列表};`
  * 优势
    * 强作用域，其作用域限制在枚举类中
    * 转换限制，枚举类对象不可以与整型隐式地互相转换
    * 可以指定底层类型

## 第5章：数据的共享与保护

### 作用域与生存期

* 标识符的作用域
  * 作用域是一个标识符在程序正文中有效的区域
  * 作用域分类
    * 函数原型作用域
    * 局部作用域（块作用域）
    * 类作用域
      * 类的成员具有类作用域，其范围包括类体和非内联成员函数的函数体
      * 如果在类作用域以外访问类的成员，要通过类名（访问静态成员），或者该类的对象名、对象引用、对象指针（访问非静态成员）
    * 文件作用域
      * 不在前述各个作用域中出现的声明，就具有文件作用域，这样声明的标识符其作用域开始于声明点、结束于文件尾
    * 命名空间作用域
* 对象的生存期
  * 静态生存期
    * 这种生存期与程序的运行期相同，在文件作用域中声明的对象具有这种生存期
    * 在函数内部声明静态生存期对象，要冠以关键字 `static`
  * 动态生存期
    * 块作用域中声明的，没有用 `static` 修饰的对象是动态生存期的对象（习惯称局部生存期对象）
    * 开始于程序执行到声明点时，结束于命名该标识符的作用域结束处

### 静态成员（注意与常成员区别）

* 静态数据成员
  * 用关键字 `static` 声明
  * 为该类的所有对象共享，静态数据成员具有静态生存期
  * 必须在类外定义和初始化，用 `::` 来指明所属的类
* 静态函数成员
  * 类外代码可以使用类名和作用于操作符来调用静态成员函数
  * 静态成员函数主要用于处理该类的静态数据成员，可以直接调用静态成员函数
  * 如果访问非静态成员，要通过对象来访问

### 共享数据的保护

* 对于既需要共享、又需要防止改变的数据应该声明为常类型（用 `const` 进行修饰）
  * 常量
    * 在 `C++11` 里，用 `constexpr` 来定义真正的常量，或实现常量初始化
    * `constexpr` 的变量的值必须是编译器在编译的时候就可以确定的，而 `const` 的变量的值无此要求而只是指明变量值不可后续更改
  * **常对象**
    * 常对象的声明形式：`const 类名 对象名`
    * 常对象必须进行初始化，不能被更新
    * 通过常对象只能调用它的常成员函数
  * 常数据成员
    * 常数据成员：使用 `const` 说明的数据成员
  * **常引用**
    * 常引用的声明形式：`const  类型说明符  &引用名`
    * 常引用所引用的对象不能被更新
    * 如果用常引用做形参，便不会意外地发生对实参的更改
  * 常数组
    * 常数组的声明形式：`类型说明符  const  数组名[大小]...`
    * 常数组的元素不能被更新（详见第6章）
  * 常指针：指向常量的指针（详见第6章）。
  * ...
* 对于不改变对象状态的成员函数应该声明为常函数
  * **常函数成员**
    * 常成员函数的声明形式：`类型说明符  函数名（参数表）const;`，这里 `const` 是函数类型的一个组成部分，因此在实现部分也要带 `const` 关键字。
    * 常成员函数不更新对象的数据成员
    * `const` 关键字可以被用于参与对重载函数的区分
  * `constexpr` 函数
    * `constexpr` 函数语法规定
      * `constexpr` 修饰的函数在其所有参数都是 `constexpr` 时，一定返回`constexpr`
      * 函数体中必须有且仅有一条 `return`语句
    * `constexpr`函数举例
      ```c++
      constexpr int get_size() { return 20; }
      constexpr int foo = get_size();
      ```

### 宏与预编译命令

* 使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之
  * 不要在 `.h` 文件中定义宏
  * 在马上要使用时才进行 `#define`,使用后要立即 `#undef`
  * 不要只是对已经存在的宏使用 `#undef`，选择一个不会冲突的名称
  * 不要试图使用展开后会导致 `C++` 构造不稳定的宏，不然也至少要附上文档说明其行为
  * 不要用 `##` 处理函数，类和变量的名字。

## 第6章：数组、指针与字符串

### 数组

* 数组的存储与初始化
  * 数组元素在内存中顺次存放，它们的地址是连续的
  * 数组元素间物理地址上的相邻，对应着逻辑次序上的相邻
  * 数组变量名是数组首元素的内存地址，是一个常量，不能被赋值
* 数组作为函数的参数
  * 数组元素作实参，与单个变量一样
  * 数组名作参数，形、实参数都应是数组名（实质上是地址），类型要一样
  * 数组做参数时传送的是数组首地址，对形参数组的改变会直接影响到实参数组

### 指针

* 指针的概念、定义和指针运算
  * 内存空间的访问方式：通过变量名访问；通过地址访问
  * 指针的概念
    * 指针：内存地址，用于间接访问内存单元
    * 指针变量：用于存放地址的变量
  * 与地址相关的运算—— `*` 和 `&`
    * 指针运算符：`*`
    * 地址运算符：`&`
* 指针的初始化和赋值
  * 指针变量的初始化：`存储类型 数据类型 *指针名 = 初始地址;`
    * 用变量地址作为初值时，该变量必须在指针初始化之前已声明过，且变量类型应与指针类型一致
    * 可以用一个已有合法值的指针去初始化另一个指针变量
    * 不要用一个内部非静态变量去初始化 `static` 指针
    * 未赋初值的指针变量自动赋任意地址值
  * 指针变量的赋值运算：`指针名 = 地址;`
    * “地址”中存放的数据类型与指针类型必须相符
      * 一个指针变量的地址只能赋给指向这种类型的指针变量，与该指针变量本身的类型不同，因此不能直接赋值给该指针变量
      * 允许定义或声明指向 `void` 类型的指针。该指针可以被赋予任何类型对象的地址
    * 向指针变量赋的值
      * 必须是地址常量或变量，例如：
        * 通过地址运算 `&` 求得已定义的变量和对象的起始地址
        * 动态内存分配成功时返回的地址
        * 常量存储在编译文件中，不能取地址，也就**不能赋值**给指针变量
      * 不能是普通整数，但整数 `0` 作为一个例外可以赋给指针来表示空指针
  * 指针空值 `nullptr`
    * 以往用 `0` 或者 `NULL` 去表达空指针的问题是：`C/C++` 的 `NULL` 宏是个被有很多潜在问题的宏。因为有的库把其定义成整数 `0`，有的定义成 `(void *)0`。在 `C` 的时代还好。但是在 `C++` 的时代，这就会引发很多问题。
    * `C++11` 使用 `nullptr` 关键字，是表达更准确，类型安全的空指针
      * 整数用 `0`, 实数用 `0.0`, 指针用 `nullptr`, 字符 (串) 用 `'\0'`
  * 指向常量的指针与指针类型的常量
    * 指向常量的指针：不能通过指向常量的指针改变所指对象的值，但指针本身可以改变，可以指向另外的对象
      ```c++
      int a;
      const int *p1 = &a; // p1 是指向常量的指针
      int b;
      p1 = &b; // 正确，p1 本身的值可以改变
      *p1 = 1; // 编译时出错，不能通过 p1 改变所指的对象
      ```
    * 指针类型的常量：若声明指针常量，则指针本身的值不能被改变
      ```c++
      int a;
      int * const p2 = &a;
      p2 = &b; // 错误，p2 是指针常量，值不能改变
      ```
* 指针与数组
  * 用指针访问数组元素
    * 数组是一组连续存储的同类型数据，可以通过指针的算术运算，使指针依次指向数组的各个元素，进而可以遍历数组
    * 定义指向数组元素的指针
      * 定义与赋值
        ```c++
        int a[10], *pa;
        pa = &a[0]; // pa = a;
        ```
      * `a[i], *(pa+i), *(a+i), pa[i]` 都是等效的
  * 指针数组
    * 元素是指针型的数组被称为指针数组
    * 指针数组与二维数组的区别在于内存是否连续
* 指针与函数
  * 指针类型的函数参数
    * 需要数据双向传递时（引用也可以达到此效果）
      * 用指针作为函数的参数，可以使被调函数通过形参指针存取主调函数中实参指针指向的数据，实现数据的双向传递
    * 需要传递一组数据，只传首地址的运行效率比较高
      * 实参是数组名时形参可以是指针
    * **函数参数列表中, 所有引用参数都必须是 `const`**。
      ```c++
      void Foo(const string &in, string *out);
      ```
      * 事实上这在 Google Code 是一个硬性约定：输入参数是值参或 `const` 引用，输出参数为指针。输入参数可以是 `const` 指针，但决不能是非 `const` 的引用参数，除非用于交换，比如 `swap()`。
  * 指针类型的函数
    * 指针函数的声明形式：`存储类型 数据类型 *函数名();`
    * 注意事项
      * 不要将非静态局部地址用作函数的返回值
        * 在子函数定义局部变量后将其地址返回给主函数，就是非法地址
      * 返回的指针要确保在主调函数是有效、合法的地址
        * 主函数中定义的数组，在子函数对该数组元素进行某种操作后，返回其中一个元素的地址，这是合法有效的地址
        * 在子函数中通过动态内存分配 `new` 操作取得的内存地址返回给主函数是合法有效的，但是内存分配和释放不在同一级别，要注意不能忘记释放以避免内存泄漏
  * 指向函数的指针
    * 函数指针的声明形式：`存储类型 数据类型 (*函数指针名)();`
    * 函数指针的典型用途：实现函数回调
      * 通过函数指针调用的函数
        * 利用将函数的指针作为参数传递给一个函数，使得在处理相似事件时可以灵活使用不同的方法
      * 调用者不关心谁是被调用者
        * 需知道存在一个具有特定原型和限制条件的被调用函数

### 其他专题

* 对象指针
  * 声明形式：`类名 *对象指针名;`
  * 通过指针访问对象成员：`*对象指针名->成员名`
    * `ptr->getx()` 相当于 `(*ptr).getx()`
  * `this` 指针
    * 指向当前对象自己，并隐含于类的每一个非静态成员函数中，用于指出成员函数所操作的对象。
    * 当通过一个对象调用成员函数时，系统先将该对象的地址赋给 `this` 指针，然后调用成员函数，成员函数对对象的数据成员进行操作时，就隐含使用了 `this` 指针
      * `Point` 类的 `getX` 函数中 `return x;` 相当于 `return this->x`
* 动态内存分配
  * 动态申请内存操作符 `new`
    * 使用方法：`new 类型名T（初始化参数列表）`
    * 功能：在程序执行期间，申请用于存放 `T` 类型对象的内存空间，并依初值列表赋以初值。
    * 结果值
      * 成功：`T` 类型的指针，指向新分配的内存
      * 失败：抛出异常
  * 释放内存操作符 `delete`
    * 使用方法：`delete 指针p`
    * 功能：释放指针 `p` 所指向的内存，`p` 必须是 `new` 操作的返回值
  * 将动态数组封装成类
    * 更加简洁，便于管理
    * 可以在访问数组元素前检查下标是否越界
    * `element` 函数返回对象的引用，可以用来操作封装数组对象内部的数组元素
      * 如果返回“值”则只是返回了一个“副本”，通过“副本”是无法操作原来数组中的元素的
* 智能指针
  * 显式管理内存在是能上有优势，但容易出错
  * `C++11` 提供智能指针的数据类型，对垃圾回收技术提供了一些支持，实现一定程度的内存管理
    * `unique_ptr`：不允许多个指针共享资源，可以用标准库中的 `move` 函数转移指针
    * `shared_ptr`：多个指针共享资源
    * `weak_ptr`：可复制 `shared_ptr`，但其构造或者释放对资源不产生影响
* `vector` 对象
  * 为什么需要 `vector`?
    * 封装任何类型的动态数组，自动创建和删除。
    * 数组下标越界检查。
  * 声明形式：`vector<元素类型> 数组对象名(数组长度);`
    * `vector` 数组对象名不表示数组首地址
  * 使用方法
    * 对数组元素的引用：与普通数组具有相同形式 `vector 对象名 [ 下标表达式 ]`
    * 获得数组长度：用 `size` 函数 `数组对象名.size()`
* 对象复制与移动
  * 浅层复制和深层复制
    * 浅层复制：实现对象间数据元素的一一对应复制。
    * 深层复制：当被复制的对象数据成员 是指针类型时，不是复制该指针成员本身，而是将指针所指对象进行复制。
* 字符串
  * 字符串常量（例如 `"program"`）
    * 各字符连续、顺序存放，每个字符占一个字节，以 `'\0'`结尾，相当于一个隐含创建的字符常量数组
    * `"program"` 出现在表达式中，表示这一 `char` 数组的首地址
      * 首地址可以赋给 `char` 常量指针：`const char *STRING = "program"`
  * 用字符数组（`C` 风格字符串）表示字符串
    * 表示方法
      ```c++
      char str[8] = {'p', 'r', 'o', 'g', 'r', 'a', 'm', '\0'};
      char str[8] = "program";
      char str[] = "program";
      ```
    * 缺点
      * 执行连接、拷贝、比较等操作，都需要显式调用库函数，很麻烦
      * 当字符串长度很不确定时，需要用 `new` 动态创建字符数组，最后要用 `delete` 释放，很繁琐
      * 字符串实际长度大于为它分配的空间时，会产生数组下标越界的错误
  * 用 `string` 类表示字符串
    * `string` 实际上是对字符数组操作的封装
    * `string` 类常用构造函数
      ```c++
      string(); // 默认构造函数，建立一个长度为0的串
      string(const char *s); // 用指针s所指向的字符串常量初始化string对象
      string(const string& rhs); // 复制构造函数
      ```
    * 输入整行字符串
      * 用 `cin` 的 `>>` 操作符输入字符串，会以空格作为分隔符，空格后的内容会在下一回输入时被读取
      * `getline` 可以输入整行字符串（要包含 `string` 头文件），如 `getline(cin, s2);`
      * 输入字符串时，可以使用其它分隔符作为字符串结束的标志（例如逗号、分号），将分隔符作为 `getline` 的第3个参数即可，如 `getline(cin, s2, ',');`
