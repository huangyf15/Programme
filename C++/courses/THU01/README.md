# `THU01`

## 第1-3章：绪论，`C++`简单程序设计与函数

### 面向对象的基本概念

#### 对象
* 一般意义上的对象：现实世界中实际存在的事物。
* 面向对象方法中的对象：程序中用来描述客观事物的实体。

#### 抽象与分类

* 分类依据的原则——抽象；
* 抽象出同一类对象的共同属性和行为形成类；
* 类与对象是类型与实例的关系。

#### 封装

* 隐蔽对象的内部细节；
* 对外形成一个边界；
* 只保留有限的对外接口；
* 使用方便、安全性好。

#### 继承

* 意义在于软件复用；
* 改造、扩展已有类形成新的类。

#### 多态

* 同样的消息作用在不同对象上，可以引起不同的行为。

### 程序的开发过程

#### 程序

* 源程序：
  * 用源语言写的，有待翻译的程序；
* 目标程序：
  * 源程序通过翻译程序加工以后生成的机器语言程序；
* 可执行程序：
  * 连接目标程序以及库中的某些文件，生成的一个可执行文件；
  * 例如：Windows系统平台上的.EXE文件。

#### 三种不同类型的翻译程序

* 汇编程序：
  * 将汇编语言源程序翻译成目标程序；
* 编译程序：
  * 将高级语言源程序翻译成目标程序；
* 解释程序：
  * 将高级语言源程序翻译成机器指令，边翻译边执行。

#### C++程序的开发过程

* 算法与数据结构设计；
* 源程序编辑；
* 编译；
* 连接；
* 测试；
* 调试。

### 函数的调用与重载

* 函数的嵌套调用
* 函数的递归调用
* 函数的重载（多态性的体现）

### 函数的参数传递

* 值传递
  * 用于传递参数值，是一种单向传递
  * 从时间开销的角度，值传递要比引用传递更大
* 引用传递
  * 引用（`&`）是标识符的别名，可以作为形参，是一种双向传递
  * 使用引用传递可以实现多个返回值，而常引用可以保障实参数据的安全
  * 定义一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象
  ```c++
  #include <iostream>
  using namespace std;
  void swap_ref(int &a,int &b) {
    int t = a;
    a = b;
    b = t;
  }
  void swap_val(int a,int b) {
    int t = a;
    a = b;
    b = t;
  }
  int main() {
    int x = 5, y = 10;
    cout << "Origin: x =" << x << "; y =" << y << endl;
    swap_val(x,y);
    cout << "Value: x =" << x << "; y =" << y << endl;
    swap_ref(x,y);
    cout << "Reference: x =" << x << "; y =" << y << endl;
    return 0;
  }
  ```

### 特殊类型的函数

* 含有可变参数的函数
  * `C++` 标准中提供了两种主要的方法
    * 如果所有的实参类型相同，可以传递一个名为 `initializer_list` 的标准库类型
    * 如果实参的类型不同，我们可以编写可变参数的模板（第9章）
  * `initializer_list` 是一个类模板
    * 使用模板时，需要在模板名字后面跟一对尖括号，括号内给出类型参数，如
      * `initializer_list<string> ls;`
    * 对象中的元素永远是常量值，我们无法改变该对象中元素的值
    * 含有 `initializer_list` 形参的函数也可以同时拥有其他形参
* 内联函数
* 带默认参数值的函数
* `constexpr` 函数
  * constexpr函数语法规定
    * `constexpr` 的变量的值必须是编译器在编译的时候就可以确定的，而 `const` 的变量的值无此要求而只是指明变量值不可后续更改；
    * `constexpr` 修饰的函数在其所有参数都是 `constexpr` 时，一定返回`constexpr`；
    * 函数体中必须有且仅有一条 `return`语句。
  * `constexpr`函数举例
  ```c++
  constexpr int get_size() { return 20; }
  constexpr int foo = get_size();
  ```

## 第4章：类与对象

### 类的组合

* 前向引用声明某个类后，可在之后的其他类的成员函数中将该类作为参数类型使用

### 结构体和联合体

* 结构体
  * 结构体是一种特殊形态的类
    * 与类的唯一区别：类的缺省访问权限是 `private`，结构体的缺省访问权限是`public`
    * 结构体存在的主要原因：与C语言保持兼容
  * 什么时候用结构体而不用类
    * 定义主要用来保存数据、而没有什么操作的类型
    * 人们习惯将结构体的数据成员设为公有，因此这时用结构体更方便
* 联合体
  * 声明形式与结构体相同
  * 成员共用同一组内存单元
  * 任何两个成员不会同时有效

### 枚举类

* 声明形式
  * `enum class 枚举类型名: 底层类型 {枚举值列表};`
* 优势
  * 强作用域，其作用域限制在枚举类中
  * 转换限制，枚举类对象不可以与整型隐式地互相转换
  * 可以指定底层类型


## 第5章：数据的共享与保护

## 第6章：数组、指针与字符串