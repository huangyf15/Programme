# THU01

> **TODO**: Chapter 12

## 第1-4章：绪论，`C++`简单程序设计，函数

### 面向对象的基本概念

* 对象
  * 一般意义上的对象：现实世界中实际存在的事物。
  * 面向对象方法中的对象：程序中用来描述客观事物的实体。
* 抽象与分类
  * 分类依据的原则——抽象；
  * 抽象出同一类对象的共同属性和行为形成类；
  * 类与对象是类型与实例的关系。
* 封装
  * 隐蔽对象的内部细节；
  * 对外形成一个边界；
  * 只保留有限的对外接口；
  * 使用方便、安全性好。
* 继承
  * 意义在于软件复用；
  * 改造、扩展已有类形成新的类。
* 多态
  * 同样的消息作用在不同对象上，可以引起不同的行为。

### 程序的开发过程

* 程序
  * 源程序：用源语言写的，有待翻译的程序；
  * 目标程序：源程序通过翻译程序加工以后生成的机器语言程序；
  * 可执行程序：连接目标程序以及库中的某些文件，生成的一个可执行文件。例如 Windows 系统平台上的 `.EXE` 文件。
* 三种不同类型的翻译程序
  * 汇编程序：将汇编语言源程序翻译成目标程序；
  * 编译程序：将高级语言源程序翻译成目标程序；
  * 解释程序：将高级语言源程序翻译成机器指令，边翻译边执行。
* C++程序的开发过程
  * 算法与数据结构设计；
  * 源程序编辑；
  * 编译，连接；
  * 测试，调试。

### 函数的调用与重载

* 函数的嵌套调用
* 函数的递归调用
* 函数的重载（多态性的体现）

### 函数的参数传递

* 值传递
  * 用于传递参数值，是一种单向传递
  * 从时间开销的角度，值传递要比引用传递更大
* 引用传递
  * 引用（`&`）是标识符的别名，可以作为形参，是一种双向传递
  * 使用引用传递可以实现多个返回值，而常引用可以保障实参数据的安全
  * 定义一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象
  ```c++
  #include <iostream>
  using namespace std;
  void swap_ref(int &a,int &b) {
    int t = a;
    a = b;
    b = t;
  }
  void swap_val(int a,int b) {
    int t = a;
    a = b;
    b = t;
  }
  int main() {
    int x = 5, y = 10;
    cout << "Origin: x =" << x << "; y =" << y << endl;
    swap_val(x,y);
    cout << "Value: x =" << x << "; y =" << y << endl;
    swap_ref(x,y);
    cout << "Reference: x =" << x << "; y =" << y << endl;
    return 0;
  }
  ```

### 特殊类型的函数

* 含有可变参数的函数
  * `C++` 标准中提供了两种主要的方法
    * 如果所有的实参类型相同，可以传递一个名为 `initializer_list` 的标准库类型
    * 如果实参的类型不同，我们可以编写可变参数的模板（第9章）
  * `initializer_list` 是一个类模板
    * 使用模板时，需要在模板名字后面跟一对尖括号，括号内给出类型参数，如
      * `initializer_list<string> ls;`
    * 对象中的元素永远是常量值，我们无法改变该对象中元素的值
    * 含有 `initializer_list` 形参的函数也可以同时拥有其他形参
* 内联函数
* 带默认参数值的函数

## 第4-5章：类与对象，数据的共享与保护

### 类的组合

* 前向引用声明某个类后，可在之后的其他类的成员函数中将该类作为参数类型使用

### 结构体、联合体与枚举类

* 结构体
  * 结构体是一种特殊形态的类
    * 与类的唯一区别：类的缺省访问权限是 `private`，结构体的缺省访问权限是`public`
    * 结构体存在的主要原因：与C语言保持兼容
  * 什么时候用结构体而不用类
    * 定义主要用来保存数据、而没有什么操作的类型
    * 人们习惯将结构体的数据成员设为公有，因此这时用结构体更方便
* 联合体
  * 声明形式与结构体相同
  * 成员共用同一组内存单元
  * 任何两个成员不会同时有效
* 枚举类
  * 声明形式
    * `enum class 枚举类型名: 底层类型 {枚举值列表};`
  * 优势
    * 强作用域，其作用域限制在枚举类中
    * 转换限制，枚举类对象不可以与整型隐式地互相转换
    * 可以指定底层类型

### 作用域与生存期

* 标识符的作用域
  * 作用域是一个标识符在程序正文中有效的区域
  * 作用域分类
    * 函数原型作用域
    * 局部作用域（块作用域）
    * 类作用域
      * 类的成员具有类作用域，其范围包括类体和非内联成员函数的函数体
      * 如果在类作用域以外访问类的成员，要通过类名（访问静态成员），或者该类的对象名、对象引用、对象指针（访问非静态成员）
    * 文件作用域
      * 不在前述各个作用域中出现的声明，就具有文件作用域，这样声明的标识符其作用域开始于声明点、结束于文件尾
    * 命名空间作用域
* 对象的生存期
  * 静态生存期
    * 这种生存期与程序的运行期相同，在文件作用域中声明的对象具有这种生存期
    * 在函数内部声明静态生存期对象，要冠以关键字 `static`
  * 动态生存期
    * 块作用域中声明的，没有用 `static` 修饰的对象是动态生存期的对象（习惯称局部生存期对象）
    * 开始于程序执行到声明点时，结束于命名该标识符的作用域结束处

### 静态成员（注意与常成员区别）

* 静态数据成员
  * 用关键字 `static` 声明
  * 为该类的所有对象共享，静态数据成员具有静态生存期
  * 必须在类外定义和初始化，用 `::` 来指明所属的类
* 静态函数成员
  * 类外代码可以使用类名和作用于操作符来调用静态成员函数
  * 静态成员函数主要用于处理该类的静态数据成员，可以直接调用静态成员函数
  * 如果访问非静态成员，要通过对象来访问

### 共享数据的保护

* 对于既需要共享、又需要防止改变的数据应该声明为常类型（用 `const` 进行修饰）
  * 常量
    * 在 `C++11` 里，用 `constexpr` 来定义真正的常量，或实现常量初始化
    * `constexpr` 的变量的值必须是编译器在编译的时候就可以确定的，而 `const` 的变量的值无此要求而只是指明变量值不可后续更改
  * **常对象**
    * 常对象的声明形式：`const 类名 对象名`
    * 常对象必须进行初始化，不能被更新
    * 通过常对象只能调用它的常成员函数
  * 常数据成员
    * 常数据成员：使用 `const` 说明的数据成员
  * **常引用**
    * 常引用的声明形式：`const  类型说明符  &引用名`
    * 常引用所引用的对象不能被更新
    * 如果用常引用做形参，便不会意外地发生对实参的更改
  * 常数组
    * 常数组的声明形式：`类型说明符  const  数组名[大小]...`
    * 常数组的元素不能被更新（详见第6章）
  * 常指针：指向常量的指针（详见第6章）。
  * ...
* 对于不改变对象状态的成员函数应该声明为常函数
  * **常函数成员**
    * 常成员函数的声明形式：`类型说明符  函数名（参数表）const;`，这里 `const` 是函数类型的一个组成部分，因此在实现部分也要带 `const` 关键字。
    * 常成员函数不更新对象的数据成员
    * `const` 关键字可以被用于参与对重载函数的区分
  * `constexpr` 函数
    * `constexpr` 函数语法规定
      * `constexpr` 修饰的函数在其所有参数都是 `constexpr` 时，一定返回`constexpr`
      * 函数体中必须有且仅有一条 `return`语句
    * `constexpr`函数举例
      ```c++
      constexpr int get_size() { return 20; }
      constexpr int foo = get_size();
      ```

### 宏与预编译命令

* 使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之
  * 不要在 `.h` 文件中定义宏
  * 在马上要使用时才进行 `#define`,使用后要立即 `#undef`
  * 不要只是对已经存在的宏使用 `#undef`，选择一个不会冲突的名称
  * 不要试图使用展开后会导致 `C++` 构造不稳定的宏，不然也至少要附上文档说明其行为
  * 不要用 `##` 处理函数，类和变量的名字。

## 第6章：数组、指针与字符串

### 数组

* 数组的存储与初始化
  * 数组元素在内存中顺次存放，它们的地址是连续的
  * 数组元素间物理地址上的相邻，对应着逻辑次序上的相邻
  * 数组变量名是数组首元素的内存地址，是一个常量，不能被赋值
* 数组作为函数的参数
  * 数组元素作实参，与单个变量一样
  * 数组名作参数，形、实参数都应是数组名（实质上是地址），类型要一样
  * 数组做参数时传送的是数组首地址，对形参数组的改变会直接影响到实参数组

### 指针

* 指针的概念、定义和指针运算
  * 内存空间的访问方式：通过变量名访问；通过地址访问
  * 指针的概念
    * 指针：内存地址，用于间接访问内存单元
    * 指针变量：用于存放地址的变量
  * 与地址相关的运算—— `*` 和 `&`
    * 指针运算符：`*`（解引用，即引用指针变量指向的变量）
    * 地址运算符：`&`（取地址，即取出变量的地址）
  * 指针与引用的差别（摘自[网站](https://blog.csdn.net/Amanda_wr/article/details/89287201)） 
    * 从内存来讲，系统为指针分配内存空间，而引用与绑定的的对象共享内存空间，系统不为引用变量分配内存空间。
    * 指针初始化以后可以改变指向的对象，而引用定义的时候必须要初始化，且初值以后不允许再绑定对象。
    * 引用对象是直接访问，指针访问是间接访问。
* 指针的初始化和赋值
  * 指针变量的初始化：`存储类型 数据类型 *指针名 = 初始地址;`
    * 用变量地址作为初值时，该变量必须在指针初始化之前已声明过，且变量类型应与指针类型一致
    * 可以用一个已有合法值的指针去初始化另一个指针变量
    * 不要用一个内部非静态变量去初始化 `static` 指针
    * 未赋初值的指针变量自动赋任意地址值
  * 指针变量的赋值运算：`指针名 = 地址;`
    * “地址”中存放的数据类型与指针类型必须相符
      * 一个指针变量的地址只能赋给指向这种类型的指针变量，与该指针变量本身的类型不同，因此不能直接赋值给该指针变量
      * 允许定义或声明指向 `void` 类型的指针。该指针可以被赋予任何类型对象的地址
    * 向指针变量赋的值
      * 必须是地址常量或变量，例如：
        * 通过地址运算 `&` 求得已定义的变量和对象的起始地址
        * 动态内存分配成功时返回的地址
        * 常量存储在编译文件中，不能取地址，也就**不能赋值**给指针变量
      * 不能是普通整数，但整数 `0` 作为一个例外可以赋给指针来表示空指针
  * 指针空值 `nullptr`
    * 以往用 `0` 或者 `NULL` 去表达空指针的问题是：`C/C++` 的 `NULL` 宏是个被有很多潜在问题的宏。因为有的库把其定义成整数 `0`，有的定义成 `(void *)0`。在 `C` 的时代还好。但是在 `C++` 的时代，这就会引发很多问题。
    * `C++11` 使用 `nullptr` 关键字，是表达更准确，类型安全的空指针
      * 整数用 `0`, 实数用 `0.0`, 指针用 `nullptr`, 字符 (串) 用 `'\0'`
  * 指向常量的指针与指针类型的常量
    * 指向常量的指针：不能通过指向常量的指针改变所指对象的值，但指针本身可以改变，可以指向另外的对象
      ```c++
      int a;
      const int *p1 = &a; // p1 是指向常量的指针
      int b;
      p1 = &b; // 正确，p1 本身的值可以改变
      *p1 = 1; // 编译时出错，不能通过 p1 改变所指的对象
      ```
    * 指针类型的常量：若声明指针常量，则指针本身的值不能被改变
      ```c++
      int a;
      int * const p2 = &a;
      p2 = &b; // 错误，p2 是指针常量，值不能改变
      ```
* 指针与数组
  * 用指针访问数组元素
    * 数组是一组连续存储的同类型数据，可以通过指针的算术运算，使指针依次指向数组的各个元素，进而可以遍历数组
    * 定义指向数组元素的指针
      * 定义与赋值
        ```c++
        int a[10], *pa;
        pa = &a[0]; // pa = a;
        ```
      * `a[i], *(pa+i), *(a+i), pa[i]` 都是等效的
  * 指针数组
    * 元素是指针型的数组被称为指针数组
    * 指针数组与二维数组的区别在于内存是否连续
* 指针与函数
  * 指针类型的函数参数
    * 需要数据双向传递时（引用也可以达到此效果）
      
      * 用指针作为函数的参数，可以使被调函数通过形参指针存取主调函数中实参指针指向的数据，实现数据的双向传递
    * 需要传递一组数据，只传首地址的运行效率比较高
      
      * 实参是数组名时形参可以是指针
    * **函数参数列表中, 所有引用参数都必须是 `const`**。
      ```c++
      void Foo(const string &in, string *out);
      ```
      * 事实上这在 Google Code 是一个硬性约定：输入参数是值参或 `const` 引用，输出参数为指针。输入参数可以是 `const` 指针，但决不能是非 `const` 的引用参数，除非用于交换，比如 `swap()`。
  * 指针类型的函数
    * 指针函数的声明形式：`存储类型 数据类型 *函数名();`
    * 注意事项
      * 不要将非静态局部地址用作函数的返回值
        * 在子函数定义局部变量后将其地址返回给主函数，就是非法地址
      * 返回的指针要确保在主调函数是有效、合法的地址
        * 主函数中定义的数组，在子函数对该数组元素进行某种操作后，返回其中一个元素的地址，这是合法有效的地址
        * 在子函数中通过动态内存分配 `new` 操作取得的内存地址返回给主函数是合法有效的，但是内存分配和释放不在同一级别，要注意不能忘记释放以避免内存泄漏
  * 指向函数的指针
    * 函数指针的声明形式：`存储类型 数据类型 (*函数指针名)();`
    * 函数指针的典型用途：实现函数回调
      * 通过函数指针调用的函数
        * 利用将函数的指针作为参数传递给一个函数，使得在处理相似事件时可以灵活使用不同的方法
      * 调用者不关心谁是被调用者
        * 需知道存在一个具有特定原型和限制条件的被调用函数

### 其他专题

* 对象指针
  * 声明形式：`类名 *对象指针名;`
  * 通过指针访问对象成员：`*对象指针名->成员名`
    * `ptr->getx()` 相当于 `(*ptr).getx()`
  * `this` 指针
    * 指向当前对象自己，并隐含于类的每一个非静态成员函数中，用于指出成员函数所操作的对象。
    * 当通过一个对象调用成员函数时，系统先将该对象的地址赋给 `this` 指针，然后调用成员函数，成员函数对对象的数据成员进行操作时，就隐含使用了 `this` 指针
      * `Point` 类的 `getX` 函数中 `return x;` 相当于 `return this->x`
* 动态内存分配
  * 动态申请内存操作符 `new`
    * 使用方法：`new 类型名T（初始化参数列表）`
    * 功能：在程序执行期间，申请用于存放 `T` 类型对象的内存空间，并依初值列表赋以初值。
    * 结果值
      * 成功：`T` 类型的指针，指向新分配的内存
      * 失败：抛出异常
  * 释放内存操作符 `delete`
    * 使用方法：`delete 指针p`
    * 功能：释放指针 `p` 所指向的内存，`p` 必须是 `new` 操作的返回值
  * 将动态数组封装成类
    * 更加简洁，便于管理
    * 可以在访问数组元素前检查下标是否越界
    * `element` 函数返回对象的引用，可以用来操作封装数组对象内部的数组元素
      * 如果返回“值”则只是返回了一个“副本”，通过“副本”是无法操作原来数组中的元素的
* 智能指针
  * 显式管理内存在是能上有优势，但容易出错
  * `C++11` 提供智能指针的数据类型，对垃圾回收技术提供了一些支持，实现一定程度的内存管理
    * `unique_ptr`：不允许多个指针共享资源，可以用标准库中的 `move` 函数转移指针
    * `shared_ptr`：多个指针共享资源
    * `weak_ptr`：可复制 `shared_ptr`，但其构造或者释放对资源不产生影响
* `vector` 对象
  * 为什么需要 `vector`?
    * 封装任何类型的动态数组，自动创建和删除。
    * 数组下标越界检查。
  * 声明形式：`vector<元素类型> 数组对象名(数组长度);`
    * `vector` 数组对象名不表示数组首地址
  * 使用方法
    * 对数组元素的引用：与普通数组具有相同形式 `vector 对象名 [ 下标表达式 ]`
    * 获得数组长度：用 `size` 函数 `数组对象名.size()`
* 对象复制与移动
  * 浅层复制和深层复制
    * 浅层复制：实现对象间数据元素的一一对应复制。
    * 深层复制：当被复制的对象数据成员 是指针类型时，不是复制该指针成员本身，而是将指针所指对象进行复制。
* 字符串
  * 字符串常量（例如 `"program"`）
    * 各字符连续、顺序存放，每个字符占一个字节，以 `'\0'`结尾，相当于一个隐含创建的字符常量数组
    * `"program"` 出现在表达式中，表示这一 `char` 数组的首地址
      * 首地址可以赋给 `char` 常量指针：`const char *STRING = "program"`
  * 用字符数组（`C` 风格字符串）表示字符串
    * 表示方法
      ```c++
      char str[8] = {'p', 'r', 'o', 'g', 'r', 'a', 'm', '\0'};
      char str[8] = "program";
      char str[] = "program";
      ```
    * 缺点
      * 执行连接、拷贝、比较等操作，都需要显式调用库函数，很麻烦
      * 当字符串长度很不确定时，需要用 `new` 动态创建字符数组，最后要用 `delete` 释放，很繁琐
      * 字符串实际长度大于为它分配的空间时，会产生数组下标越界的错误
  * 用 `string` 类表示字符串
    * `string` 实际上是对字符数组操作的封装
    * `string` 类常用构造函数
      ```c++
      string(); // 默认构造函数，建立一个长度为0的串
      string(const char *s); // 用指针s所指向的字符串常量初始化string对象
      string(const string& rhs); // 复制构造函数
      ```
    * 输入整行字符串
      * 用 `cin` 的 `>>` 操作符输入字符串，会以空格作为分隔符，空格后的内容会在下一回输入时被读取
      * `getline` 可以输入整行字符串（要包含 `string` 头文件），如 `getline(cin, s2);`
      * 输入字符串时，可以使用其它分隔符作为字符串结束的标志（例如逗号、分号），将分隔符作为 `getline` 的第3个参数即可，如 `getline(cin, s2, ',');`

## 第7-8章：继承、派生与多态

### 继承方式的访问控制

* 基本概念
  * 访问限定符分类
    * 类的三种成员：`public` 成员、`protected` 成员、`private` 成员（默认）
    * 三种继承方式：`public` 继承、`protected` 继承、`private` 继承（默认）
  * 开放与封闭特性
    * 成员 member 对类 Class 完全开放：类 Class 的成员函数与对象可直接访问成员 member
    * 成员 member 对类 Class 部分开放：类 Class 的成员函数可直接访问成员 member，但类 Class 的对象不可直接访问该成员
    * 成员 member 对类 Class 完全封闭：类 Class 的成员函数与对象均不可直接访问成员 member
  * 水平与垂直访问
    * 水平访问：成员 Base.member 对其所在类 Base 的成员函数和对象来说
    * 垂直访问：成员 Base.member 对其（直接）派生类 Derived 的成员函数和对象来说
* 继承的访问控制（按基类的成员类型分类）
  * 对于基类的 `public` 成员
    * **基类中的成员函数、基类的对象均可直接访问**
    * 公有继承：**派生类中的成员函数、通过派生类的对象均可直接访问**（仍以 `public` 身份出现在派生类中）
    * 保护继承：**派生类中的成员函数可以直接访问**，通过派生类的对象不可直接访问（即以 `protected` 身份出现在派生类中）
    * 私有继承：**派生类中的成员函数可以直接访问**，通过派生类的对象不可直接访问（即以 `private` 身份出现在派生类中）
  * 对于基类的 `protected` 成员
    * **基类中的成员函数可以直接访问**，基类的对象不可直接访问
    * 公有继承：**派生类中的成员函数可以直接访问**，通过派生类的对象不可直接访问（仍以 `protected` 身份出现在派生类中）
    * 保护继承：**派生类中的成员函数可以直接访问**，通过派生类的对象不可直接访问（仍以 `protected` 身份出现在派生类中）
    * 私有继承：**派生类中的成员函数可以直接访问**，通过派生类的对象不可直接访问（即以 `private` 身份出现在派生类中）
  * 对于基类的 `private` 成员
    * **基类中的成员函数可以直接访问**，基类的对象不可直接访问
    * 三种继承方式下：派生类中的成员函数、通过派生类的对象也均不能直接访问（不可直接访问）
* 归纳
  * 类继承的访问权限符的特征
    * 派生类成员函数对基类成员的访问权限：三种继承方式下 `public, protected` 成员可以直接访问，`private` 成员不可直接访问
    * 通过派生类对象对基类成员的访问权限：只有公有继承时的 `public` 成员可以直接访问，其余情况均不可直接访问
  * 类成员的访问限定符的特征
    * `public` 成员：水平访问完全开放，垂直访问由继承方式决定直接派生类中的身份（即基类公有成员在直接派生层的特性直接由继承方式决定）
    * `protected` 成员：水平访问部分开放，垂直访问亦部分开放，但采用私有继承时转变为私有成员（此时基类保护成员的“部分开放”特性只维持到直接派生层）
    * `private` 成员：水平访问部分开放，垂直访问完全封闭（即基类私有成员的“部分开放”特性只维持到本层）
  * `protected` 成员的特点及意义
    * 对建立其所在类来说（水平访问），它与 `private` 成员的性质相同
    * 对于其派生类来说（垂直访问），除了公有继承外，它与 `public` 成员的性质基本相同
    * 由此，既实现了水平访问意义下的数据隐藏，又方便垂直访问意义下的继承，实现代码重用
* 多继承：如果派生类有多个基类，也就是多继承时，可以用不同的方式继承每个基类

### 派生相关的类型转换

* 公有派生类对象可以被当作基类的对象使用，反之则不可。
  * 派生类的对象可以隐含转换为基类对象；
  * 派生类的对象可以初始化基类的引用；
  * 派生类的指针可以隐含转换为基类的指针。
* 通过基类对象名、指针只能使用从基类继承的成员。

### 派生类的构造与析构

#### 构造函数

* 继承关系
  * 基类的构造函数默认不被继承，派生类需要定义自己的构造函数。
  * `C++11` 规定：可用 `using` 语句继承基类构造函数（`using B::B;`），但是只能初始化从基类继承的成员；派生类新增成员可以通过类内初始值进行初始化。
  * 如果派生类有自己新增的成员，且需要通过构造函数初始化，则派生类要自定义构造函数，此时：
    * 派生类新增成员：派生类定义构造函数初始化；
    * 继承来的成员：自动调用基类构造函数进行初始化；
    * 派生类的构造函数需要给基类的构造函数传递参数。
* 两种情况
  * 单继承：派生类只有一个直接基类的情况，是单继承。单继承时，派生类的构造函数只需要给一个直接基类构造函数传递参数。
    ```c++
    派生类名::派生类名(基类所需的形参，本类成员所需的形参)
        : 基类名(参数表), 本类成员初始化列表 {
      //其他初始化；
    }；
    ```
  * 多继承：多继承时，有多个直接基类，如果不继承基类的构造函数，派生类构造函数需要给所有基类构造函数传递参数。
    ```c++
    派生类名::派生类名(参数表)
        : 基类名1(基类1初始化参数表), 
          基类名2(基类2初始化参数表), 
          ...
          基类名n(基类n初始化参数表), 
          本类成员初始化列表 {
      //其他初始化；
    }；
    ```
* 执行顺序
  1. 调用基类构造函数。
      * 顺序按照它们被继承时声明的顺序（从左向右）。
  2. 对初始化列表中的成员进行初始化。
      * 顺序按照它们在类中定义的顺序。
      * 对象成员初始化时自动调用其所属类的构造函数。由初始化列表提供参数。
  3. 执行派生类的构造函数体中的内容。

#### 复制构造函数

* 派生类未定义复制构造函数的情况
  * 继承关系：编译器会在需要时生成一个隐含的复制构造函数
  * 执行顺序：先调用基类的复制构造函数，再为派生类新增的成员执行复制
* 派生类定义了复制构造函数的情况
  * 继承关系：一般都要为基类的复制构造函数传递参数。复制构造函数只能接受一个参数，既用来初始化派生类定义的成员，也将被传递给基类的复制构造函数。
  * 基类的复制构造函数形参类型是基类对象的引用，实参可以是派生类对象的引用
    * 例如: `C::C(const C &c1) : B(c1) {…}`

#### 析构函数

* 继承关系：析构函数默认不被继承
  * 派生类如果需要，要自行声明析构函数，声明方法与无继承关系时类的析构函数相同。
  * 不需要显式地调用基类的析构函数，系统会自动隐式调用。
* 执行顺序：先执行派生类析构函数的函数体，再调用基类的析构函数。

### 派生类成员的标识与访问

#### 访问从基类继承的成员

* 作用域限定：当派生类与基类有相同成员时：
  * 如未特别限定，则通过派生类对象使用的是派生类中的同名成员
  * 如要通过派生类对象访问基类中被隐藏的同名成员，应使用基类名和作用域操作符（`::`）来限定
* 二义性问题I
  * 如果从不同基类继承了同名成员，但是在派生类没有定义同名成员，“`派生类对象名或引用名.成员名`”、“`派生类指针->成员名`”访问成员存在二义性问题
  * 解决方式：用类名限定

#### 虚基类

* 二义性问题II
  * 当派生类从多个基类派生，而这些基类又共同基类，则在访问此共同基类中的成员时，将产生冗余，并有可能因冗余带来不一致性
  * 解决方式：为最远的派生类提供唯一的基类成员，而不重复产生多次复制
* 声明方式及作用
  * 以 `virtual` 说明基类继承方式：`class B1: virtual public B`
  * 作用：解决多继承时可能发生的对同一基类继承多次而产生的二义性问题，注意要在第一级继承时就将共同基类设计为虚基类
* 虚基类及其派生类构造函数
  * 建立对象时所指定的类称为最远派生类，且在建立对象时只有最远派生类的构造函数调用虚基类的构造函数，其他类对虚基类构造函数的调用被忽略。虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。
  * 在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中为虚基类的构造函数列出参数。如果未列出，则表示调用该虚基类的默认构造函数。

### 运算符重载

* 简介
  * 运算符重载是对已有的运算符赋予多重含义，使同一个运算符作用于不同类型的数据时导致不同的行为。
    * `C++` 几乎可以重载全部的运算符，而且只能够重载C++中已经有的。
    * 不能重载的运算符：“`.`”、“`.*`”、“`::`”、“`?:`”
    * 重载之后运算符的优先级和结合性都不会改变。
    * 基础数据类型之间的操作符无法重载。
  * 运算符重载是针对新类型数据的实际需要，对原有运算符进行适当的改造。例如：
    * 使复数类的对象可以用“`+`”运算符实现加法；
    * 使时钟类对象可以用“`++`”运算符实现时间增加1秒。
* 典型情形
  * 双目运算符重载为类的非静态成员函数；
  * 单目运算符重载为类的非静态成员函数；
  * 运算符重载为非成员函数。

### 虚函数和抽象类

* 虚函数简介
  * `C++` 中的虚函数用 `virtual` 关键字说明，是动态绑定的函数，也是实现运行时多态性的基础
  * 虚函数必须是非静态的成员函数，虚函数经过派生之后，就可以实现运行过程中的多态。
  * 虚函数一般不声明为内联函数，因为对虚函数的调用需要动态绑定，而对内联函数的处理是静态的。
  * 一般成员函数可以是虚函数，构造函数不能是虚函数，析构函数可以是虚函数
    * 由于可能需要通过基类指针删除派生类对象，或者需要允许其他人通过基类指针调用对象的析构函数（通过 `delete` 这样做是正常的），这是就需要让基类的析构函数成为虚函数，否则执行 `delete` 的结果是不确定的。
* 虚函数的声明
  * 虚函数的声明：`virtual 函数类型 函数名(形参表);`
  * 虚函数声明只能出现在类定义中的函数原型声明中，而不能在成员函数实现的时候。
  * 在派生类中可以对基类中的成员函数进行覆盖，并且派生类中的虚函数还会隐藏基类中同名函数的所有其它重载形式。
  * 派生类可以不显式地用 `virtual` 声明虚函数。即如果从名称、参数及返回值三个方面检查之后，派生类中满足下列条件的某个函数成员就会自动确定为虚函数，此时派生类的虚函数便覆盖了基类的虚函数。
    * 该函数是否与基类的虚函数有相同的名称、参数个数及对应参数类型；
    * 该函数是否与基类的虚函数有相同的返回值或者满足类型兼容规则的指针、引用型的返回值。
  * 一般习惯于在派生类的函数中也使用 `virtual` 关键字，以增加程序的可读性。
* 虚表与动态绑定
  * 虚表
    * 每个多态类有一个虚表（`virtual table`）
    * 虚表中有当前类的各个虚函数的入口地址
    * 每个对象有一个指向当前类的虚表的指针（虚指针 `vptr`），64 位系统中占据的内存为 8 个字节
  * 动态绑定的实现
    * 构造函数中为对象的虚指针赋值
    * 通过多态类型的指针或引用调用成员函数时，通过虚指针找到虚表，进而找到所调用的虚函数的入口地址
    * 通过该入口地址调用虚函数
* 抽象类
  * 纯虚函数
    * 纯虚函数是一个在基类中声明的虚函数，它在该基类中没有定义具体的操作内容，要求各派生类根据实际需要定义自己的版本，纯虚函数的声明格式为：
    * 声明方式：`virtual 函数类型 函数名(参数表) = 0;`
  * 抽象类
    * 带有纯虚函数的类称为抽象类:
    ```c++
    class 类名 {
      virtual 类型 函数名(参数表) = 0;
      //其他成员……
    }
    ```
    * 作用
      * 抽象类为抽象和设计的目的而声明
      * 将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。
      * 对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。
    * 注意
      * 抽象类只能作为基类来使用。
      * 不能定义抽象类的对象。
* `override` 和 `final`
  * 多态行为的基础：基类声明虚函数，继承类声明一个函数覆盖该虚函数
    * 覆盖要求：函数签名（signatture）完全一致
    * 函数签名包括：`函数名 参数列表 const`
  * 显式函数覆盖 `override`
    * `C++11` 引入显式函数覆盖，在编译期而非运行期捕获此类错误。在虚函数显式重载中运用，编译器会检查基类是否存在一虚拟函数，与派生类中带有声明 `override` 的虚拟函数，有相同的函数签名（signature）；若不存在，则会报错。例如
      ```c++
      class Base { virtual void f() const; }
      class Derived : public Base { virtual void f() override; } // 编译错误：Derived::f() 与 Base::f() 的函数签名不同，不允许覆盖
      ```
  * 显式继承禁止 `final`
    * `C++11` 提供 `final`，用来避免类被继承，或是基类的函数被改写。例如：
      ```c++
      class Base1 final { };
      class Derived1 : public Base1 { }; // 编译错误：Base1 为 final，不允许被继承
      class Base2 { virtual void f() final; }
      class Derived2 : public Base2 { void f(); } // 编译错误：Base2::f 为 final，不允许被覆盖
      ```

## 第9-10章：模板与群体数据、泛型程序设计与 `C++` 标准模板库

（略）

## 第11章：流类库与输入/输出

### I/O流的概念及流类库结构

* 程序与外界环境的信息交换
  * 当程序与外界环境进行信息交换时，存在着两个对象：程序中的对象、文件对象。
  * 流是一种抽象，负责在数据的生产者和数据的消费者之间建立联系，并管理数据的流动。
* 流对象与文件操作的关系
  * 程序建立一个流对象
  * 指定这个流对象与某个文件对象建立连接
  * 程序操作流对象
  * 流对象通过文件系统对所连接的文件对象产生作用
* 提取与插入
  * 读操作在流数据抽象中被称为（从流中）提取
  * 写操作被称为（向流中）插入

### 输出流

* 最重要的三个输出流
  * ostream 类最适合用于顺序文本模式输出。
  * ofstream 类支持磁盘文件输出。
  * ostringstream 类支持内存中的字符串输出。
* 预先定义的输出流对象
  * cout 标准输出
  * cerr 标准错误输出，没有缓冲，发送给它的内容立即被输出。
  * clog 类似于 cerr，但是有缓冲，缓冲区满时被输出。
  * Note. 标准输出换向
    ```c++
    ofstream fout("b.out");
    streambuf* pOld = cout.rdbuf(fout.rdbuf());  
    //…
    cout.rdbuf(pOld);
    ```
* 构造输出流对象
  * ofstream 类支持磁盘文件输出
  * 如果在构造函数中指定一个文件名，当构造这个文件时该文件是自动打开的
    ```c++
    ofstream myFile("filename");
    ```
  * 可以在调用默认构造函数之后使用open成员函数打开文件
    ```c++
    ofstream myFile;           //声明一个静态文件输出流对象
    myFile.open("filename");   //打开文件，使流对象与文件建立联系
    ```
  * 在构造对象或用open打开文件时可以指定模式
    ```c++
    ofstream myFile("filename", ios_base::out | ios_base::binary);
    ```
* 文件输出流成员函数的三种类型
  * 与操纵符等价的成员函数。
  * 执行非格式化写操作的成员函数。
  * 其它修改流状态且不同于操纵符或插入运算符的成员函数。
* 文件输出流成员函数
  * open 函数：把流与一个特定的磁盘文件关联起来（可以指定打开模式）
  * put 函数：把一个字符写到输出流中
  * write 函数：把内存中的一块内容写到一个文件输出流中
  * seekp 和 tellp 函数：操作文件流的内部指针
  * close 函数：关闭与一个文件输出流关联的磁盘文件
  * 错误处理函数：在写到一个流时进行错误处理

#### 向文本文件输出

* 标准输出设备显示器被系统看作文本文件，所以我们以向标准设备输出为例，介绍文本文件输出格式控制
  * 插入(<<)运算符：为所有标准 C++ 数据类型预先设计的，用于传送字节到一个输出流对象。
* 操纵符（manipulator）
  * 插入运算符与操纵符一起工作：控制输出格式
  * 很多操纵符都定义在 `ios_base` 类中（如 `hex()`）、头文件（如`setprecision()`）。
  * 控制输出宽度：在流中放入 `setw` 操纵符或调用 `width` 成员函数为每个项指定输出宽度。注意：`setw` 和 `width` 仅影响紧随其后的输出项，但其它流格式操纵符保持有效直到发生改变。
  * 控制默认进制：`dec`、`oct`和 `hex` 操纵符用于设置输入和输出的默认进制。
* `setiosflags` 操纵符
  * 可以通过使用带参数的 `setiosflags` 操纵符来设置左对齐，`setiosflags` 定义在头文件 `iomanip` 中。
  * 参数 `iosbase::left` 是 `iosbase` 的静态常量，因此引用时必须包括`ios_base::` 前缀。
  * `setiosflags` 不同于 `width` 和 `setw`，它的影响是持久的，直到用 `resetiosflags` 重新恢复默认值时为止。
  * `setiosflags` 的参数是该流的格式标志值，可用按位或（`|`）运算符进行组合

#### 向二进制文件输出

* 二进制文件流
  * 使用 `ofstream` 构造函数中的模式参量 `ios_base::binary` 指定二进制输出模式；
  * 以通常方式构造一个流，然后使用 `setmode` 成员函数，在文件打开后改变模式；
  * 通过二进制文件输出流对象完成输出。
* 以二进制的格式写入到磁盘的速度比按照文本格式输出的效率要高
  * 原因：内存中是按照二进制格式存储的，如果按照文本格式输出，需要将二进制格式转变为文本格式。

#### 向字符串输出

* 字符串输出流（`ostringstream`）
  * 功能
    * 可以实现将其他数据类型转换为字符串的功能
    * 支持 `ofstream` 类的除 `open`、`close` 外的所有操作
    * `str` 函数可以返回当前已构造的字符串
  * 典型应用：将数值转换为字符串

### 输入流

* 重要的输入流类
  * istream 类最适合用于顺序文本模式输入。cin 是其实例。
  * ifstream 类支持磁盘文件输入。
  * istringstream 类支持内存中的字符串输入。
* 构造输入流对象
  * 如果在构造函数中指定一个文件名，在构造该对象时该文件便自动打开。 
    ```c++
    ifstream myFile("filename");
    ```
  * 在调用默认构造函数之后使用open函数来打开文件。
    ```c++
    ifstream myFile;         //建立一个文件流对象
    myFile.open("filename"); //打开文件"filename”
    ```
  * 打开文件时可以指定模式
    ```c++
    ifstream myFile("filename", iosbase::in | iosbase::binary);
    ```
* 使用提取运算符从文本文件输入
  * 提取运算符(>>)对于所有标准C++数据类型都是预先设计好的，是从一个输入流对象获取字节最容易的方法。
  * ios 类中的很多操纵符都可以应用于输入流。但是只有少数几个对输入流对象具有实际影响，其中最重要的是进制操纵符 dec、oct 和 hex。
* 输入流相关函数
  * open 把该流与一个特定磁盘文件相关联。
  * get 功能与提取运算符（>>）很相像，主要的不同点是get函数在读入数据时包括空白字符。
  * getline 功能是从输入流中读取多个字符，并且允许指定输入终止字符，读取完成后，从读取的内容中删除终止字符。
  * read 从一个文件读字节到一个指定的内存区域，由长度参数确定要读的字节数。当遇到文件结束或者在文本模式文件中遇到文件结束标记字符时结束读取。
  * seekg 用来设置文件输入流中读取数据位置的指针。
  * tellg 返回当前文件读指针的位置。
  * close 关闭与一个文件输入流关联的磁盘文件。

#### 从字符串输入

* 字符串输入流（`istringstream`）
  * 功能
    * 可以实现从字符串读取数据
    * 在构造函数中设置要读取的字符串
    * 支持 `ifstream` 类的除 `open`、`close` 外的所有操作
  * 典型应用：将字符串转换为数值

### 输入/输出流

* 两个重要的输入/输出流
  * 一个 `iostream` 对象可以是数据的源或目的。
  * 两个重要的 I/O 流类都是从 `iostream` 派生的，它们是 `fstream` 和 ` stringstream`。这些类继承了前面描述的 `istream` 和 `ostream` 类的功能。
* `fstream` 类
  * `fstream` 类支持磁盘文件输入和输出。
  * 如果需要在同一个程序中从一个特定磁盘文件读并写到该磁盘文件，可以构造一个 `fstream` 对象。
  * 一个 `fstream` 对象是有两个逻辑子流的单个流，两个子流一个用于输入，另一个用于输出。
* `stringstream` 类
  * `stringstream` 类支持面向字符串的输入和输出
  * 可以用于对同一个字符串的内容交替读写，同样是由两个逻辑子流构成。

## 第12章：异常处理

### 异常处理中的构造与析构

* 自动的析构
  * 找到一个匹配的 catch 异常处理后
    * 初始化异常参数。
    * 将从对应的 try 块开始到异常被抛掷处之间构造（且尚未析构）的所有自动对象进行析构。
  * 从最后一个 catch 处理之后开始恢复执行。

### 标准异常类的基础

* exception：标准程序库异常类的公共基类
* logic_error：可以在程序中被预先检测到的异常
  * 如果小心地编写程序，这类异常能够避免
* runtime_error：表示难以被预先检测的异常

### 正确性 -> 容错性