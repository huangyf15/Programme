# 第三章 字符串、向量和数组

> Last updated: Aug 19, 2020
> Author: Yunfan Huang

### using 声明
- 可使**`using`**声明某个命名空间。例如 `using std::cin;`表示使用命名空间`std`中的名字`cin`。注意，这样比`using namespace std;`更安全。
- 头文件中不应该包含`using`声明。否则，每个使用了该头文件的源码也会使用这个声明，会带来风险。

### 字符串  string
```c++
#include <string>
using std::string;
```

- 标准库类型`string`表示可变长的字符序列。
- 字符串字面值和**`string`**是不同的类型。
#### 定义和初始化 string 对象

| 方式 | 解释 |
| -- | -- |
| `string s1` | 默认初始化，`s1`是个空字符串 |
| `string s2(s1)` | `s2`是`s1`的副本 |
| `string s2 = s1` | 等价于`s2(s1)`，`s2`是`s1`的副本 |
| `string s3("value")` | `s3`是字面值“value”的副本，**除了字面值最后的那个空字符外** |
| `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值"value"的副本 |
| `string s4(n, 'c')` | 把`s4`初始化为由连续`n`个字符`c`组成的串 |

- 拷贝初始化（copy initialization）：使用等号`=`将一个已有的对象拷贝到正在创建的对象。
- 直接初始化（direct initialization）：通过括号给对象赋值。

#### string 对象上的操作

| 操作 | 解释 |
|-----|-----|
| `os << s` | 将`s`写到输出流`os`当中，返回`os` |
| `is >> s` | 从`is`中读取字符串赋给`s`，字符串以空白分割，返回`is` |
| `getline(is, s)` | 从`is`中读取一行赋给`s`，返回`is` |
| `s.empty()` | `s`为空返回`true`，否则返回`false` |
| `s.size()` | 返回`s`中字符的个数，类型为`size_type`（属于无符号类型） |
| `s[n]` | 返回`s`中第`n`个字符的引用，位置`n`从0计起 |
| `s1+s2` | 返回`s1`和`s2`连接后的结果 |
| `s1=s2` | 用`s2`的副本代替`s1`中原来的字符 |
| `s1==s2` | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
| `s1!=s2` | 同上 |
| `<`, `<=`, `>`, `>=` | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感 |

- string 对象的读写
    - 执行读操作`>>`：忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止。
    - `getline`：读取一整行（**包括空格和制表符**），直到遇到换行符为止。

#### 处理 string 对象中的字符

* **建议**：使用`C++`版本的`C`标准库头文件。
  * `C++`修改了`C`的标准库，名称为去掉`.h`，前面加`c`。
  * 如：`name.h`被重新命名为了`cname`。
* `cctype`头文件的标准函数

| 函数 | 解释 |
|-----|-----|
| `isalnum(c)` | 当`c`是字母或数字时为真 |
| `isalpha(c)` | 当`c`是字母时为真 |
| `iscntrl(c)` | 当`c`是控制字符时为真 |
| `isdigit(c)` | 当`c`是数字时为真 |
| `isgraph(c)` | 当`c`不是空格但可以打印时为真 |
| `islower(c)` | 当`c`是小写字母时为真 |
| `isprint(c)` | 当`c`是可打印字符时为真 |
| `ispunct(c)` | 当`c`是标点符号时为真 |
| `isspace(c)` | 当`c`是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |
| `isupper(c)` | 当`c`是大写字母时为真 |
| `isxdigit(c)` | 当`c`是十六进制数字时为真 |
| `tolower(c)` | 当`c`是大写字母，输出对应的小写字母；否则原样输出`c` |
| `toupper(c)` | 当`c`是小写字母，输出对应的大写字母；否则原样输出`c` |

### 向量 vector

```c++
#include <vector>
using std::vector;
```

- 是个**容器**：可以包含其他对象，但所有的对象必须类型相同。
- 是个类模板：本身不是类，但可**实例化**（instantiation）出一个类。
  - `vector`是一个模板，`vector<int>`是一个类型。
  - 通过将类型放在类模板名称后面的**尖括号**中来指定**类型**，如`vector<int> ivec`。

#### 定义和初始化 vector 对象

| 方法 | 解释 |
|-----|-----|
| `vector<T> v1` | `v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
| `vector<T> v2(v1)` | `v2`中包含有`v1`所有元素的副本 |
| `vector<T> v2 = v1` | 等价于`v2(v1)`，`v2`中包含`v1`所有元素的副本 |
| `vector<T> v3(n, val)` | `v3`包含了n个重复的元素，每个元素的值都是`val` |
| `vector<T> v4(n)` | `v4`包含了n个重复地执行了值初始化的对象 |
| `vector<T> v5{a, b, c...}` | `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值 |
| `vector<T> v5={a, b, c...}` | 等价于`v5{a, b, c...}` |

- 列表初始化： `vector<string> v{"a", "an", "the"};` （C++11）
- **建议**：先定义一个空的`vector`对象，再在运行时向其中添加具体值

#### `vector`支持的操作

| 操作 | 解释 |
|-----|-----|
| `v.emtpy()` | 如果`v`不含有任何元素，返回真；否则返回假 |
| `v.size()` |  返回`v`中元素的个数|
| `v.push_back(t)` | 向`v`的尾端添加一个值为`t`的元素 |
| `v[n]` | 返回`v`中第`n`个位置上元素的**引用** |
| `v1 = v2` | 用`v2`中的元素拷贝替换`v1`中的元素  |
| `v1 = {a,b,c...}` | 用列表中元素的拷贝替换`v1`中的元素 |
| `v1 == v2` | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| `v1 != v2` | 同上 |
| `<`,`<=`,`>`, `>=` | 以字典顺序进行比较 |

* `vector`及`string`对象的下标运算符只可用于访问已存在的元素
  * 试图用下标形式去访问一个不存在的元素将引发错误，但这种错误不会被编译器发现，而是在运行时产生一个不可预知的值
  * 确保下标合法的一种有效手段就是**尽可能使用范围`for`语句**

#### 范围`for`（range for）语句

- `for (auto c : str)`可用于访问字符串`str`中的字符
- `for (auto &c : str)`使用引用直接改变字符串`str`中的字符
- **警告**：范围`for`语句体内不应改变其遍历序列的大小！

### 迭代器 iterator

- 包括`vector`在内的所有标准库容器都可以使用迭代器，但只有少数几种才同时支持下标运算符。
  - `string`不属于容器类型，但支持很多与容器类型类似的操作
- 类似于指针类型，迭代器也提供了对对象的间接访问。有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。

#### 使用迭代器

```c++
vector<int> v{1,2,3,4};
auto b = v.begin(); // 返回指向第一个元素的迭代器
auto e = v.end();   // 返回指向最后一个元素的下一个的迭代器
```

- `end`成员指向容器（或`string`对象）尾元素的下一位置（one past the end），常被称作尾后迭代器（off-the-end iterator）或简称为尾迭代器（end iterator）。如果容器为空， `begin()`和 `end()`返回的是同一个迭代器，都是尾后迭代器。

- 迭代器（iterator）：每种标准容器都有自己的迭代器。`C++`倾向于用迭代器而不是下标遍历元素。

  - **建议**：养成使用迭代器和`!=`的习惯（泛型编程）。
  - **警告**：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。

- 迭代器类型

  ```c++
  vector<int>::iterator it1;       // it1 能读写 vector<int> 的元素
  string::iterator it2;            // it2 能读写 string 对象中的字符
  vector<int>::const_iterator it3; // it3 只能读元素，不能写元素
  string::const_iterator it4;      // it4 只能读字符，不能写字符
  ```

#### 迭代器运算

标准容器迭代器的运算符:

| 运算符 | 解释 |
|-----|-----|
| `*iter` | 成员访问，返回迭代器`iter`所指向的**元素的引用** |
| `iter->mem` | 解引用 + 成员访问，等价于`(*iter).mem` |
| `++iter` | 令`iter`指示容器中的下一个元素 |
| `--iter` | 令`iter`指示容器中的上一个元素 |
| `iter1 == iter2` | 判断两个迭代器是否相等 |

`vector`和`string`迭代器支持的运算：

| 运算符 | 解释 |
|-----|-----|
| `iter + n` | 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter - n` | 迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置。 |
| `iter1 += n` | 迭代器加法的复合赋值语句，将`iter1`加n的结果赋给`iter1` |
| `iter1 -= n` | 迭代器减法的复合赋值语句，将`iter2`减n的加过赋给`iter1` |
| `iter1 - iter2` | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置。 |
| `>`、`>=`、`<`、`<=` | 迭代器的关系运算符 |

- **`difference_type`**：保证足够大以存储任何两个迭代器对象间的距离，可正可负。

### 数组 array

- 数组除**大小固定**这一特点外，其他用法与`vector`基本类似。
- **建议：尽量使用标准库类型而非数组**
  - 应当尽量使用`vector`和迭代器而非内置数组和指针
  - 应当尽量使用`string`而非`C`风格的基于数组的字符串

#### 定义和初始化内置数组

- 初始化方式

  ```c++
  const unsigned sz = 3;
  int ia1[sz] = {0, 1, 2};     // 数组长度必须是常量表达式
  int ia2[] = {0, 1, 2};       // 可不写，让编译器自己推断
  char ca1[] = {'C', '+', '+'};// 数组 ca1 的维度是 3
  char ca2[] = "C++";          // 数组 ca2 的维度是 4
  ```

  - 数组不允许直接赋值给另一个数组。
  - 字符数组可用字符串字面值进行显式初始化，但要注意**字符串字面值的结尾处的空字符 `'\0'`也会被拷贝进字符数组**。

- 要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。

#### 访问数组元素

- 使用**下标**访问

  - 数组元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。**数组下标通常定义为`size_t`类型，为无符号类型**。
  - 标准库类型如`vector`限定使用的下标必须是无符号类型，而**内置的下标运算符的索引值不是无符号类型，可以处理负值**。即使数组下标越界，编译器也不会报错，只能由程序员来检查。

- 使用**指针**访问

  - 对数组的元素使用取地址符就能得到指向该元素的指针。

  - 很多情况下在表达式中使用数组名时，编译器会自动将其替换为一个指向数组首元素的指针。

  - 指针也是迭代器：用数组初始化 `vector`

    ```c++
    int a[] = {1,2,3,4,5};
    int *pbeg = a;     // 等价于 p = &a[0]
    int *pend = &a[5]; // 等价于尾后迭代器
    vector<int> va2(pbeg, pend);
    vector<int> va1(begin(a), end(a)); // 与上一行等价
    ```

#### C 风格字符串

- **建议**：对大多数应用来说，使用标准库 `string`比使用`C`风格字符串更安全、更高效，后者是诸多安全问题的根本原因。

- `C`风格字符串从`C`继承而来

  - 它不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。

  - 按此习惯书写的字符串存放在字符数组中，并以空字符`\0`结束，一般利用指针来操作这些字符串。

  - 获取 `string` 中的 `cstring` 

    ```cpp
    string s("Hello World"); // 正确: 允许使用字符串字面值来初始化 string 对象
    char *str = s; // 错误: 不能用 string 对象初始化 char*
    const char *str = s.c_str(); // 正确
    ```

- `C` 标准库`<cstring>`中的 String 函数

| 函数 | 介绍 |
|-----|-----|
| `strlen(p)` | 返回`p`的长度，空字符不计算在内 |
| `strcmp(p1, p2)` | 比较`p1`和`p2`的相等性。如果`p1==p2`，返回0；如果`p1>p2`，返回一个正值；如果`p1<p2`，返回一个负值。 |
| `strcat(p1, p2)` | 将`p2`附加到`p1`之后，返回`p1`（不建议使用） |
| `strcpy(p1, p2)` | 将`p2`拷贝给`p1`，返回`p1`（不建议使用） |

#### 多维数组

- 严格来说`C++`中没有多维数组，而只有数组的数组。

- 多维数组的初始化

  ```cpp
  int ia1[3][4] = {{0,1,2,3},{0,1,2,3},{0,1,2,3}};
  int ia2[3][4] = {0,1,2,3,0,1,2,3,0,1,2,3}; // 与上等价
  int ia3[3][4] = {{0},{0},{0}}; // 只显式初始化每行首元素
  int ia4[3][4] = {0, 1, 2, 3}; // 只显式初始化第一行
  ```

- 使用范围`for`语句时，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

