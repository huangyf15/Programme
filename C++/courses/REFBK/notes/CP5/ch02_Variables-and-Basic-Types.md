# 第二章 变量和基本类型

> Last updated: Aug 17, 2020
> Author: Yunfan Huang

### 基本内置类型

#### 基本算术类型

| 类型 | 含义 | 最小尺寸|
|---|---|---|
| `bool` | 布尔类型  | 8bits |
| `char`| 字符 | 8bits |
| `wchar_t` | 宽字符 | 16bits |
| `char16_t` | Unicode字符 | 16bits |
| `char32_t` | Unicode字符 | 32bits |
| `short` | 短整型 | 16bits |
| `int` | 整型 | 16bits （在32位机器中是32bits） |
| `long` | 长整型 | 32bits |
| `long long` | 长整型 | 64bits （是在C++11中新定义的） |
| `float` | 单精度浮点数 | 6位有效数字 |
| `double` | 双精度浮点数 | 10位有效数字 |
| `long double` | 扩展精度浮点数 | 10位有效数字 |


#### 如何选择类型

1. 当明确知晓数值不可能是负数时，选用无符号类型。
2. 使用`int`执行整数运算。除非超过了`int`的范围，选择`long long`。
3. 算术表达式中不要使用`char`或`bool`。
4. 浮点运算选用`double`。

#### 类型转换

- 非布尔型赋给布尔型，初始值为0则结果为false，否则为true。
- 布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。

#### 字面值常量

一个形如`42`的值被称作**字面值常量**（literal）。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。
- 整型和浮点型字面值。
- 字符和字符串字面值。
  - 使用空格、缩进、换行连接，继承自`C`。
  - 字符字面值：单引号，`'a'`
  - 字符串字面值：双引号， `"Hello World"`；由空字符`'\0'`结尾，实际长度比内容多1
- 转义序列。`\n`、`\t`等。
- 布尔字面值。`true`，`false`。
- 指针字面值。`nullptr`。

### 变量

**变量**提供一个**具名**的、可供程序操作的存储空间。 `C++`中的每个变量都有其数据类型，数据类型决定着变量所占空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。`C++`中**变量**和**对象**一般可以互换使用。

#### 变量定义（definition）

- **定义形式**：类型说明符（type specifier） + 一个或多个变量名组成的列表。如`int sum = 0, value, units_sold = 0;`
- **初始化**（initialize）：当对象在创建时获得了一个特定的值，则称该对象被初始化了。建议初始化每一个内置类型的变量。

  - 初始化不是赋值

    - 初始化 = 创建变量 + 赋予初始值
    - 赋值 = 擦除对象的当前值 + 用新值代替

  - 初始化的不同形式

    ```cpp
    int units_sold = 0;
    int units_wold = {0};
    int units_wold{0};	// 列表初始化
    int units_wold(0);
    int units_wold;	    // 默认初始化
    ```

    - 列表初始化：使用花括号`{}`；如果使用列表初始化内置类型的变量且初始值存在丢失信息的风险，则编译器将报错。
    - 默认初始化：定义时没有指定初始值会被默认初始化；在函数体内部的内置类型变量将不会被初始化。

#### 变量的**声明**（declaration） vs  **定义**（definition）
  - 为了支持分离式编译，`C++`将声明和定义区分开。**声明**使得名字为程序所知。**定义**负责创建与名字关联的实体。
    ```cpp
    int j;                   // 声明并定义
    extern int i;            // 声明而非定义
    extern double pi = 3.14; // 定义而非声明
    double pi = 3.14;        // 与上句作用同
    ```

    * `extern`语句如果包含初始值，就不再是声明而是定义。
    * 在函数体内部不能初始化由`extern`关键字标记的变量。
      * 变量只能被定义一次，但是可以被多次声明。

- 名字的**作用域**（scope）

  * 同一个名字在不同作用域中可能指向不同的实体：变量、函数、类型等。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。
    * 全局作用域（global scope）：所有花括号之外
    * 块作用域（block scope）：某个花括号之内
      * 内层作用域（inner scope）
      * 外层作用域（outer scope）
  * 如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。如果存在局部变量与全局变量名称相同，则需要用`::var`显式地访问全局变量`var`。

### 复合类型

#### 左值和右值

- **左值**（l-value）**可以**出现在赋值语句左边或右边，比如变量；
- **右值**（r-value）**只能**出现在赋值语句右边，比如常量。

#### 引用

- 是一个对象的别名，引用类型“引用 [refer to]”另外一种类型
  - **引用必须被初始化**，如`int &refVal = val;`
  - 引用与它的初始值**绑定**（bind）在一起，而**非拷贝**
  - 引用的类型一般要和与之绑定的对象严格匹配
- 引用**并非对象**，而只是为一个已存在的对象所起的另一个名字
  - 为引用赋值，实际上是把值赋给了与引用绑定的对象，而不是让引用和另一个对象相关联。
  - 获取引用的值，实际上是获取了与引用绑定的对象的值
  - 以引用作为初始值，实际上是以与引用绑定的对象作为初值
  - 由于引用本身不是一个对象，所以不能定义引用的引用

#### 指针

- 用于存放某对象的**地址**，指针类型“指向 [point to]”另外一种类型

  - 指针无须在定义时赋初值，如 `int *ip1;`
  - 指针本身就是一个对象，允许对指针赋值和拷贝
  - 建议：**初始化所有指针**

- 指针的值

  1. 指向一个对象；

  2. 指向紧邻对象的下一个位置；

  3. 空指针；

  4. 无效指针。

- 取地址和解引用

  - `&`是**取地址符**，用于获取对象的地址
    - `int i = 42; int *p = &i;`
  -  `*`是**解引用符**，用于访问指针指向的对象
    - `cout << *p;`

- 指针的类型

  - 空指针不指向任何对象，且只能用字面常量初始化
  - `void*`指针可以存放**任意**对象的地址
  - 其他指针类型必须要与所指对象**严格匹配**
  - 两个指针相减的类型是`ptrdiff_t`
  
- 对指针的引用

  ```cpp
  int i = 42;
  int *p;     // p 是一个 int 型指针
  int *&r = p;// r 是一个对指针 p 的引用
  r = &i;     // 给 r 赋值 &i, 即令 p 指向 i
  *r = 0;     // 解引用 r 得到 p 指向的对象 i 并改为 0
  ```

  * **要理解一个变量的类型**是什么，最简单的办法是**从右向左**阅读变量的定义，离变量名最近的符号对变量的类型有最直接的影响。
    * 例如：对于`int *&r = p;`，离`r`最近的符号是`&`，因此`r`是一个引用；声明符的其余部分用以确定`r`引用的类型是什么，此例中的符号`*`说明`r`引用的是一个指针；最后，声明的基本数据类型部分指出`r`引用的是一个`int`类型的指针`p`。
    * 又如：对于`int **ppi = &pi;`，离`ppi`最近的符号是`*`，因此`ppi`是一个指针；声明符的其余部分用以确定`ppi`指向的类型是什么，此例中的符号`*`说明`ppi`指向的是一个指针；最后，声明的基本数据类型部分指出`ppi`指向的是一个`int`类型的指针`pi`。

### `const` 限定符

- `const`对象**必须初始化**，**可以读取其值**，且**不能被改变**。
- `const`变量默认不能被其他文件访问。
  - 若非要访问，必须在指定`const`前加`extern`。

#### `const` 的引用

- **对常量的引用**（reference to const）：不能通过其改变其引用的对象的值的那类常量，也常称为常引用（const reference）

  ``` c++
  const int ival = 0;
  const int &iref = ival;    // iref 是对常量的引用
  double dval = 3.14;
  const double &dref = dval; // dref 也是对常量的引用
  ```

  - 既可以引用 `const` 对象，也可以引用非 `const` 对象。

- 当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象，称为**临时量**（temporary）对象。对临时量的引用是非法行为。

#### 指针和 `const`

- **指向常量的指针**（pointer to const）：不能通过其改变其指向的对象的值的那类指针

  ```c++
  const int i = 0;
  const int *iptr = i;      // iptr 是指向常量的指针
  double d = 3.14;
  const double *dptr = &pi; // dptr 也是指向常量的指针
  ```

  - 既可以指向`const`对象，也可以指向非`const`对象。

- **常指针**（const pointer）：指针本身是常量

  ```cpp
  int i = 0;
  int *const ptri = &i;            // pi 将一直指向 i
  const double pi = 3.14;
  const double *const ptrpi = &pi; // pip 是一个常量指针，它指向一个常量对象 pi
  ```

  - 常指针仅意味着不能改变指针指向的对象，但当其指向非`const`对象时，仍可以通过其修改其所指对象的值。

#### 顶层 `const`

```cpp
int i = 0;
int *const p1 = &i;      // 不能改变 p1 的值，这是一个顶层 const
const int ci = 42;       // 不能改变 ci 的值，这是一个顶层 const
const int *p2 = &ci;     // 允许改变 p2 的值，这是一个底层 const
const int *const p3 = p2;// 靠右的 const 是顶层 const, 靠左的是底层 const
const int &r = ci;       // 用于声明引用的 const 都是底层 const
```

- 顶层`const`：指针本身是个常量。
- 底层`const`：指针指向的对象是个常量。
- 拷贝时严格要求相同的底层`const`资格。

#### `constexpr`和常量表达式

- 常量表达式：指值不会改变，且在编译过程中就能得到计算结果的表达式。

- `C++11`新标准规定，允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量的表达式。

- 在`constexpr`声明中如果定义了一个指针，该限定符仅对指针有效，与指针所指的对象无关。

  ```c++
  const int *p = nullptr; // p 是一个指向常量的指针
  constexpr int *q = nullptr; // p 是一个常指针
  ```

### 处理类型

#### 类型别名

- 传统别名：使用**`typedef`**来定义类型的同义词

  - `typedef double wages;`

- 新标准别名：别名声明（alias declaration）

  - `using SI = Sales_item;`（C++11）

- 指针、常量和类型别名

  ```c++
  typedef char *pstring;
  const char *p1 = 0;   // p1 是指向 char 常量的指针, 声明语句的基本数据类型是 const char（char 常量）
  const pstring p2 = 0; // p2 是指向 char 的常量指针, 声明语句的基本数据类型是 const pstring（常指针）
  const pstring *p3;    // p3 是一个指针, 它的对象是指向 char 的常量指针
  ```

#### `auto`和`decltype`类型说明符

- **`auto`**类型说明符：让编译器**自动推断类型**并初始化
  - `int i = 0, &r = i; auto a = r; // a: int`
  - 一般会忽略顶层`const`
  - `const int ci = 1; const auto f = ci;// f: const int`

- **`decltype`** 类型指示符：从表达式类型推断出要定义变量的类型
  - `decltype(f()) sum = x; // sum: 函数 f 的返回类型`
  - 不会忽略顶层`const`

### 自定义数据结构

#### struct

- 类可以以关键字`struct`开始，紧跟类名和类体。
- `C++11`起可以为类数据成员提供一个**类内初始值**。

#### 编写自己的头文件

- 头文件通常包含哪些只能被定义一次的实体：类、`const`和`constexpr`变量。

#### 预处理器概述

- **预处理器**（preprocessor）：确保头文件多次包含仍能安全工作。
- 当预处理器看到`#include`标记时，会用指定的头文件内容代替`#include`
- **头文件保护符**（header guard）：头文件保护符依赖于预处理变量的状态：已定义和未定义。

```cpp
#ifndef SALES_DATA_H
#define SALES_DATA_H
struct Sale_data{
    ...
}
#endif
```
