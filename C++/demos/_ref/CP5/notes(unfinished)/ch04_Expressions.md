# 第四章 表达式

> Last updated: Aug 19, 2020
>
> Author: Yunfan Huang
>
> **TODO**: Sec 4.2-4.10, 4.12 to be modified

### 表达式基础

- 表达式：由一个或多个运算对象（operand）组成，对表达式求值将得到一个结果（result）
    - 字面值和变量是最简单的表达式（expression），其结果就是字面值和变量的值
    - 把一个运算符（operator）和一个或多个运算对象组合起来可以生成较复杂的表达式

#### 基本概念

- 运算对象转换（Sec 4.11）
- 重载运算符（Chapter 14）
- 左值和右值
    - `C`中原意：**左值**（l-value）**可以**出现在赋值语句左边或右边，比如变量；**右值**（r-value）**只能**出现在赋值语句右边，比如常量。
    - `C++`中含义：当一个对象被用作**右值**的时候，用的是对象的**值**（内容）；被用做**左值**时，用的是对象的**身份**（在内存中的位置）。
    - 一个重要的原则：在需要右值的地方可以用左值来代替，但不能把右值当成左值（也就是位置）使用。

#### 复合表达式

* 复合表达式：指含有两个或多个运算符的表达式
* 求值顺序、优先级与结合律
  * 优先级：高优先级运算符的运算对象比低优先级的更紧密
  * 结合律：优先级相同的组合规则由结合律确定，包括左/右
  * 求值顺序：确定组合方式后各运算对象的求值顺序
    * `C++`语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地，这实际上是在代码生成效率和程序潜在缺陷之间进行了权衡。
* **建议**：处理复合表达式
  * 拿不准时最好用括号来强制确定组合关系以符合程序逻辑
  * 若改变了某个运算对象的值则表达式其余地方不要再使用它

### 具体运算符

#### 算术运算符

- 一元：`+, -`；二元：`*, /, %; +, -`
- **溢出**：当计算的结果超出该类型所能表示的范围时就会产生溢出。

#### 逻辑运算符

- 一元：`!`；二元：`<, <=, >, >=; ==, !=; &&, ||`
- **短路求值**：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。

#### 赋值运算符

- 二元：`=; +=, -=, *=, /= %=; <<=, >>=, &=, ^=, !=`
- 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。
- 赋值运算符满足右结合律，这点和其他二元运算符不一样。 `ival = jval = 0;`等价于`ival = (jval = 0);`
- 赋值运算优先级比较低。

#### 条件运算符

- 条件运算符（`?:`）：

#### 递增和递减运算符

* 一元：`++, --`
* **建议**
  * 除非必须，否则不用递增递减运算符的后置版本
  * 简洁可以成为一种美德，如`*iter++`等价于`*(iter++)`

#### 成员访问运算符

* 二元：`., ->`

#### 条件运算符

* 三元：`?:`
* **条件运算符**允许我们把简单的`if-else`逻辑嵌入到单个表达式中去。如`cond? expr1: expr2`。
* **警告**：随着条件运算嵌套层数的增加，代码的可读性急剧下降。因此，条件运算的嵌套最好别超过两到三层。

#### 位运算符

- 一元：`~`；二元：`<<, >>, &, ^, |`
- **位运算符**是作用于**整数类型**的运算对象。

#### sizeof  运算符

- 一元：`sizeof`
- **sizeof 运算符**返回一条表达式或一个类型名字所占的**字节数**。返回的类型是 `size_t`。如`sizeof (type)`和`sizeof expr`。

#### 逗号运算符

* 二元：`,`

### 类型转换

#### 隐式类型转换

- 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型，被称为算术转换。如整型提升、无符号类型的转换。
- 在初始化过程中（包括变量/函数形参初始化），初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。如数组转换为指针、指针类型的转换、非常量转换为常量、类类型定义的转换等。
- 在条件语句中，非布尔转换成布尔。如算数或指针类型转换为布尔类型等。

#### 显式类型转换

* **建议**
  * 尽量避免显式的强制类型转换，尤其是旧式的
  * `reinterpret_cast`本质上依赖于机器，因此要想安全地使用它必须对涉及的类型和编译器实现转换的过程都非常了解。
* 命名的强制类型转换：*cast-name<type>(expression);*
  * **`static_cast`**：任何明确定义的类型转换，只要不包含底层`const`，都可以使用。
    * 如`double slope = static_cast<double>(j);`、
  * **`dynamic_cast`**：支持运行时类型识别。
  * **`const_cast`**：只能改变运算对象的底层`const`。一般只建议在有重载函数的上下文中使用，用于增加/去除`const`性质。
    * 如`const char *pc; char *p = const_cast<char*>(pc);`
  * **`reinterpret_cast`**：通常为运算对象的位模式提供低层次上的重新解释。
* 旧式的强制类型转换：*type (expression);* 或 *(type) expression;*
  * 根据所涉及的类型不同，旧式的强制类型转换分别具有与`const_cast`、`static_cast`或`reinterpret_cast`的行为。
