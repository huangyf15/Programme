# Part 02: Structure

> Last updated: 5, 6.1-6.5, 7

## Ch 05: 控制逻辑

* 复合表达式
* 判断逻辑
* 循环逻辑
* 异常处理

## Ch 06: 类型系统

* `Julia` 采用单继承方式，这与 `C++` 提供多继承方式有显著不同
* `Julia` 的复合类型 `struct` 内部并未提供成员函数的定义语法，类型仅仅是类型
* 在开发过程中，使用可变对象还是不可变对象，可以参考以下两点。如果答案都为“否”，则建议使用不可变类型。
  * 当两个对象具备相同的成员值集合时，是否需要识别为不同的事物
  * 对象之间是否会随时独立地进行值的变换

## Ch 07: 函数

* 基本定义
  * 在使用 `Julia` 进行程序开发过程中，尤其是关键计算处，最好都能够明确地限定参变量的类型
  * 对于改变了参变量原有数据的函数，`Julia` 建议使用感叹号 `!` 表示这种函数，这并非强制而是希望以惯例的形式进行提醒
* 参数传递方式
  * 默认参数
  * 键值参数
  * 可变参数
* 函数对象
  * 在 `Julia` 中，函数也是可操作的对象，其类型为 `Function`
  * `+` 等运算符同样也具有 `Function` 类型，因此可以写 `add = +`
  * 函数可作为参数传递，此时最好限定参数为 `Function` 类型
  * 函数可作为其他函数的返回值，函数内部也可再次定义一个函数
* 匿名函数
  ```julia
  # 语法 1
  function (参数表)
    # 实现体
  end

  # 语法 2
  (参数表) -> 复合表达式
  
  # 语法 3
  调用函数名(实参表) do 匿名函数参变量表
    # 匿名函数实现体
  end
  ```
* 参数化方法
  ```julia
  # 语法 1
  function 函数名(参数1::T1, 参数2::T2, ...) where {类参下界 <: T1 <: 类参上界, T2, ...}
    # 实现体
  end
  
  # 语法 2
  函数名(参数1::T1, 参数2::T2, ...) where {类参下界 <: T1 <: 类参上界, T2, ...} = 复合表达式
  ```
* 多态分发（Multiple Dispatch，又译多重派发）
  * `Julia` 的弱类型机制能让开发更快捷，但恰当的类型约束能够为程序高效、正确地执行提供保障。因此需要在具体化和抽象化之间选择合适的平衡点，既要避免过度的类型限定带来代码的膨胀及维护成本，也要确保每个函数都能够按照预期的方式准确执行，且不会出现难以预料的问题。
* 复合类型构造方法
  * 外部构造方法：应避免覆盖默认方法
    * 在创建对象或进行调用时，应尽量基于现有的尤其是默认的构造方法，尽量少地在外部新增
    * 新增外部构造方法时，最好先查看原有的方法列表，避免引入冲突导致不可预料的后果
  * 内部构造方法
    * 内部出现的任意函数或方法都会“消灭”复合类型所有的默认构造方法，无论该函数是否与该复合类型同名
    * 内部的构造方法中只能使用 `new` 关键字创建对象
  * `Julia` 的设计者建议
    * 在声明复合类型时，至少要能给出一个未全部成员提供参数的内部构造方法，并能够配有强制的错误检查
    * 其他为了便利而提供的构造方法，例如带有默认参数的方法、复合类型的辅助转换等，最好以外部方法的形式提供
    * 这样基于已知的、可预期的内部构造方法，可以更安全地提升与增强构造函数的功能


## Ch 10: 元编程

## Ch 13: 组织结构
